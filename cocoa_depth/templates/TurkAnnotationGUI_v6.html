<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
<script src="/static/javascript/TurkTools.js"></script>

<script>

// Variables obtained from the Flask server
var subj_id_list = {{ subj_id_list }};  // List of subjects to annotate
var keypoint_labels = JSON.parse({{ keypoint_labels|tojson }});

// number of trials that the turk annotator will have to complete 
// corresponds to the number of subjects
var num_trials = subj_id_list.length;

// The theoretical maximum comparisons given 13 keypoints
var MAX_COMPARISONS = 50
// Number of comparisons the user has left to accomplish
var comparisons_left = MAX_COMPARISONS

// Variable to manage the visibility of instructions
var flag_view_instructions = 1;

// Variables to manage number of trials per turker. Each trial consists 
// of annotating all the objects interacting with a specific subject
var cur_trial = 1;
var flag_trial_run = false;
var compl_trials = 0;

var newUserCheck;

// Lists of keypoints for each subject in the subj_id_list
var image_keypoints_list = {};
// Keep track of the comparisons which are unsure (and inferred unsure)
var keypoint_comparisons_unsure = []
// Keep track of the results of comparisons done and inferred
var keypoint_comparisons_res = {}
// Keep track of the order comparisons were done
var keypoint_comparisons_order = []
var keypoint_id1, keypoint_id2;

// Variable for the image to be overlaid with keypoints
var image;
var canvas;
var image_bbox_top, image_bbox_left;
var image_bbox_height, image_bbox_width;
var IMAGE_BBOX_PAD = 100;
var canvas_visible = true;


// The interval used to continuously draw the keypoints onto the canvas. It is
// needed in a global scope so it can be cleared each time a new interval must
// be made.
var drawInterval;

var mergeSortFinished = false;
var sortedKeypointIds;

// Variable to measure response times 
var startTrialTime = 0;
var totalAssignmentTime = 0;
var startAssignmentTime = 0;
var startInstructionReadTime = 0;
var totalInstructionReadTime = 0;

// variables containing mechanical turk information
var _amt_assignment_id = '';
var _amt_worker_id = '';
var _hit_id = '';
var _total_depth_str = '';
var _all_trials_res_dict = {};
var _worker_exp = 0;

$(document).ready(function() {

	startInstructionReadTime = new Date().getTime();
	
	console.debug("_____________ DEBUG _____________: in ready()");
	
	// Hide the submit button so turkers don't press it before completing task
	$('#submitButton').hide();
	// Hide the done/flag buttons so turkers don't press it before completing trial
	$('#done_buttons').hide();
	// Bind the start trial to space
	$(document).bind('keyup', 'space', SetupTrial);
	// Bind the StepMergeSort function to comparison decision clicks
	$("#green_closer_button").click(StepMergeSort);
	$("#pink_closer_button").click(StepMergeSort);
	$("#neither_closer_button").click(StepMergeSort);
	$("#toggle_canvas").click( function () { canvas_visible = !canvas_visible; } );
	$("#backtrack_comparison_button").click(Backstep);
	
	$("input[name='_hit_flag']").click( function(){ $('#submit_div').show();} );

	$("#submitButton").click( 
		function(){
			
			var _hit_results = {
				"_hit_id": parseInt(_hit_id),
				"_assignment_id": _amt_assignment_id,
				"_worker_id": _amt_worker_id,
				"_worker_exp": _worker_exp,
				"_hit_it": totalInstructionReadTime,
				"_hit_flag": $("input[name='_hit_flag']:checked").val(),
				"_hit_rt": totalAssignmentTime,
				"_gui_rating": $('#_gui_rating').val(),
				"_hit_comment": $('#_hit_comment').val(),
				"_trials_results": JSON.stringify(_all_trials_res_dict),
				"_hit_depth_str": _total_depth_str,
				"_hit_reject_flag": $('#_hit_reject_flag').val()
			};
			
			console.debug("_____________ DEBUG _____________: in submit() [" + JSON.stringify(_hit_results) + "]");
			
			$.ajax({
				url: "/cocoa_depth/{{ dataset }}/PostHITResults/",
				type: "POST",
				contentType: "application/json",
				data: JSON.stringify(_hit_results),
				dataType: "text",
				success: function( data ) {
					console.debug( "   $> PostHITResults() success" + data );
				}
			});
		}
	);
	
	if (IsOnTurk()){
		_amt_worker_id = GetWorkerId();
		console.debug('   $> worker_id: ' + _amt_worker_id);
		$('#_worker_id').val(_amt_worker_id);
		
		_amt_assignment_id = GetAssignmentId();
		console.debug('   $> assignment id: ' + _amt_assignment_id);
		$('#assignmentId').val(_amt_assignment_id);
		$('#_assignment_id').val(_amt_assignment_id);
	}
	
	var url = document.URL;
	console.debug('   $> url: ' + url);
	var tmp = url.split("/");
	if (IsOnTurk()){
		var tmp_2 = tmp[tmp.length-1];
		tmp = tmp_2.split("?");
		_hit_id = tmp[0];
	}else{
		_hit_id = tmp[tmp.length-1];
	}
	console.debug('   $> hit id: ' + _hit_id);
	$('#_hit_id').val(parseInt(_hit_id));

	write_image_keypoints_divs();
	
});

/**
 * Create html elements needed for displaying each trial.
 */
function write_image_keypoints_divs() {
		console.debug("_____________ DEBUG _____________: in write_image_keypoints_divs" + "[" + num_trials + "]");
		console.debug("_____________ DEBUG _____________: in write_image_keypoints_divs" + "[" + $('#image_container').html() + "]");        

		str = $('#image_container').html(); 
		for ( i = 1; i <= num_trials; i++ ) {
			  s = '<img class="displays" id="t' + String(i) + '_img"><canvas id="image_keypoints_canvas_' + String(i) + '" name="t' + String(i) + '_img_canvas"></canvas>'  
			  console.debug("_____________ DEBUG _____________: in write_image_keypoints_divs" + "[" + s + "]");
			  str = str + s;
		}
		console.debug("_____________ DEBUG _____________: in write_image_keypoints_divs" + "[" + str + "]");
		$('#image_container').html( str );
}

/**
 * Called at the beginning of a trial. Ensures Turkers are legitimate and have
 * read the directions carefully.
 */
function SetupTrial() {

	console.debug("_____________ DEBUG _____________: in SetupTrial()");

	// If trial is already running return so function isn't repeated
	if ( flag_trial_run ) {
		return;
	}
	// If completed trials = 0 it means turker just started HIT so check his 
	// instruction reading time and if it is less than a minute ask him to read 
	// more carefully
	if ( IsOnTurk() && compl_trials == 0 ) {

		// If worker is previewing he should first accept
		if ( IsTurkPreview() ) {
			alert("Please accept the HIT before starting!");
			return;
		}
		// If worker is on the blocked workers list do not allow him to move forward
		$.ajax({
			url: "/cocoa_depth/{{ dataset }}/IsBlockedWorker/",
			type: "POST",
			contentType: "application/json",
			data: JSON.stringify({
				"_worker_id": _amt_worker_id,
			}),
			dataType: "text",
			success: function( returned_data ) {
				
				console.debug( "   $> IsBlockedWorker() success:" + returned_data );
				if ( returned_data == 'REJECT' ){
				
					console.debug("_____________ DEBUG _____________: Blocked Worker ID: " + _amt_worker_id);
					alert("You have been blocked because of the low quality of your work. Please return HIT. Thanks!");
					return;
				
				}else{			
				
					// get timing for instruction reading
					var currentTime = new Date().getTime();
					totalInstructionReadTime = currentTime - startInstructionReadTime;
					console.debug("_____________ DEBUG _____________: Instruction reading time: " + totalInstructionReadTime);
					if (!newUserCheck){
						$('#_hit_it').val(totalInstructionReadTime);
						console.debug('   $> Read instructions first time in msec: ' + totalInstructionReadTime);
						
						//_worker_exp = IsNewWorker(_amt_worker_id);
						newUserCheck = $.ajax({
							url: "/cocoa_depth/{{ dataset }}/IsNewWorker/",
							type: "POST",
							contentType: "application/json",
							data: JSON.stringify({ "_worker_id": _amt_worker_id	}),
							dataType: "text"
						}).then(
							function( returned_data ) {
								console.debug( "   $> IsNewWorker() success _worker_exp: " + returned_data );
								_worker_exp = parseInt(returned_data);
								$('#_worker_exp').val(parseInt(returned_data));
								console.debug('   $> Worker experience is : ' + _worker_exp);
								return _worker_exp;
							}
						);
					}
					console.debug('   $> Out then : ' + _worker_exp);
					newUserCheck.then(
						function( _worker_exp ) {
							console.debug('   $> In function : ' + _worker_exp);
							if ( totalInstructionReadTime < 30000 && _worker_exp == 0) {
								console.debug('   $> In if : ' + _worker_exp);
								alert("It is your first time doing this HIT. Please take at least 30 seconds to carefully read the instructions! Thanks!");
								// Shows instructions
								flag_view_instructions = 0;
								ManageInstructions();
								return;
							}else{
								// start counting execution time
								startAssignmentTime = new Date().getTime();
								
								GetTrialData();
							}
						}
					);
				}
			}
		});
	} else {
		GetTrialData();
	}
}


/**
 * Queries the server for the data for the current trial in this hit.
 */
function GetTrialData() {
	// Set flag for running trial
	flag_trial_run = true;
	
	// Hides instructions at the beginning of trial
	flag_view_instructions = 1;
	ManageInstructions();
	
	console.debug("_____________ DEBUG _____________: in GetTrialData()");
	console.debug("   $> : " + subj_id_list[cur_trial - 1]);

	// Query Server for the entities contained in the image corresponding to this trial
	// pass 	-> the image id of current trial
	// obtain 	-> all the annotations in terms of polygons and category-ids in image
	$.ajax({
		url: "/cocoa_depth/{{ dataset }}/GetTrialData/", 
		type: "POST",
		contentType: "application/json",
		data: JSON.stringify({'_{{ dataset }}_subj_id': subj_id_list[cur_trial - 1]}),
		dataType: "json",
		success: function( data ) {
			
			console.debug("_____________ DEBUG _____________: in /GetTrialData()/success");
	
			// Extract all the info provided from the server
			
			// Url source for the image
			var img_trial_url = data["_{{ dataset }}_img_src"];
			console.debug("   $> image trial url -> " + img_trial_url );
		
			// Keypoints of the subject in the image
			var keypoints = data['_image_keypoints'];
			console.debug("   $> keypoints list -> [" + keypoints + "]");
			image_keypoints_list['image_keypoints_' + cur_trial] = keypoints

			// Keypoint bounding box. Convert from x, y, w, h to
			// top, right, bottom, left.
			// Conversion is y, x+w, y+h, x.
			// Add a bit of padding around the bbox as well.
			var keypoints_bbox = data['_keypoints_bbox'];
			// $("_keypoints_bbox").val(keypoints_bbox);
			var x = keypoints_bbox[0], y = keypoints_bbox[1], w = keypoints_bbox[2], h = keypoints_bbox[3];
			keypoints_bbox = [y-50, x+w+50, y+h+50, x-50];
			keypoints_bbox_str = '';
			for (var kc = 0; kc < keypoints_bbox.length; kc++) {
				keypoints_bbox_str += Math.floor(keypoints_bbox[kc]) + "px "
			}
			$('#t' + cur_trial + '_img').css('clip', "rect(" + keypoints_bbox_str + ")" );
			$('#t' + cur_trial + '_img').css('position', "absolute" );
			$('#t' + cur_trial + '_img').css('top', -keypoints_bbox[0] + "px" );
			$('#t' + cur_trial + '_img').css('left', -keypoints_bbox[3] + "px" );
			$('#image_container').height(h + IMAGE_BBOX_PAD);
			$('#image_container').width(w + IMAGE_BBOX_PAD);
					   
			console.log("populating image_bbox data"); 
						image_bbox_top = Math.round(Number(-keypoints_bbox[0]));
			image_bbox_left = Math.round(Number(-keypoints_bbox[3]));
			image_bbox_height = h + IMAGE_BBOX_PAD;
			image_bbox_width = w + IMAGE_BBOX_PAD;
			
			// Hide StartTrial button
			$('#startTrial').hide();
			// Show the image
			$('#t' + cur_trial + '_img').attr('src', img_trial_url );
			$('#t' + cur_trial + '_img').show();
			tmp_image = $('#t' + cur_trial + '_img')
		
			canvas = $("image_keypoints_canvas_" + cur_trial);	
			canvas.css("position", "absolute");
			canvas.offset({top:-image_bbox_top,left:-image_bbox_left});
	
			canvas.height = image_bbox_height;
			canvas.width = image_bbox_width;

			// Show annotations panel right of image
			$('#ann_container').show();
			// Show the button panel below image
			$('#button_panel').show();
			
			// Set the start time after the loading has been completed
			//date = new Date();
			startTrialTime = new Date().getTime();
			
			mergeSortFinished = false;

			DoTrial();
		}
	});

}

/**
 * Gathers depth information from the Turker each time it is called.
 *
 * Trial occurs in two phases. The first phase is a MergeSort to get an
 * ordering. The second phase is to try to reinsert the Unsure comparisons.
 */
function DoTrial() {

	console.debug("_____________ DEBUG _____________: in /DoTrial()");
	
	if (keypoint_comparisons_order.length == 0) {
		$("#backtrack_comparison_button").prop("disabled", true);
	} else {
		$("#backtrack_comparison_button").prop("disabled", false);
	}
			
	// Set image variable
	image = $('#t' + cur_trial + '_img');
	canvas = $('#image_keypoints_canvas_' + cur_trial)

	// Get indices of the existing and visible keypoints. We'll use these to
	// represent the keypoints when we sort them by depth.
	var keypoints = image_keypoints_list['image_keypoints_' + cur_trial]
	var keypoint_ids = [];
	for (var k = 0; k < keypoints.length; k += 3) {
		if (keypoints[k + 2] == 2) { // if visible
			keypoint_ids.push(k / 3)
		}
	}

	// MergeSort to find the relative depth of each keypoint
	console.debug("   $> Entering MergeSort")
	// console.log("      keypoint_ids = " + keypoint_ids);
	var res = MergeSort(keypoint_ids, 0, keypoint_ids.length, keypoints);

	console.log("\n");
	mergeSortFinished = res[0];
	if (mergeSortFinished) {
		console.debug("   $> First phase MergeSort done. Reinsert Unsure Cmps");
		// remove the temporary comparisons which are Unsure but were marked
		// Same Distance.
		/*
		for (var c = 0; c < keypoint_comparisons_unsure.length; c++) {
			delete keypoint_comparisons_res[keypoint_comparisons_unsure[c]];
		}
		*/
		
		//var res2 = ReinsertUnsureComparisons(keypoint_ids, keypoints);
		//var reinsertUnsureFinished = res2;
		//if (reinsertUnsureFinished) {
			sortedKeypointIds = res[1]
			console.debug("MERGE SORT DONE. sortedKeypointIds = " + sortedKeypointIds);
			$("#comparisons-left").html("<b>0</b> comparisons left");
			$("#pink_closer_button").hide();
			$("#green_closer_button").hide();
			$("#neither_closer_button").hide();
			$("#unsure_distance_button").hide();
			//$("#done_buttons").show();
		//}
		console.log(sortedKeypointIds);
		var stringy = "";
		for(var ki = 0; ki < sortedKeypointIds.length; ki++) {
			stringy += keypoint_labels[sortedKeypointIds[ki]] + " ";
		}
		console.log(stringy);
		NextTrial();
	}
}

/**
 * Mergesorts the sublist [ibeg, iend) of keypoint ids.
 * @param keypoint_ids: the list of indices of keypoints to be sorted
 * @param ibeg, iend: range of elements in keypoint_ids to sort
 * @param keypoints: the keypoint coordinates and visible flags
 */
function MergeSort(keypoint_ids, ibeg, iend, keypoints) {

	console.debug("   $> MergeSort on keypoint_ids from " + ibeg + " to " + iend);
	// console.log("      keypoint_ids = " + keypoint_ids);
	if (iend - ibeg <= 1) {
		return [true, keypoint_ids];
	}
	var imid = Math.floor((iend + ibeg) / 2);
	res = MergeSort(keypoint_ids, ibeg, imid, keypoints);
	if (!res[0])
		return [false, []];
	keypoint_ids = res[1];
	res = MergeSort(keypoint_ids, imid, iend, keypoints);
	if (!res[0])
		return [false, []];
	keypoint_ids = res[1];
	return Merge(keypoint_ids, ibeg, imid, iend, keypoints);
}

/**
 * Helper for MergeSort. Merges two sublists [ibeg, imid) and [imid, iend) of
 * keypoint_ids.
 */
function Merge(keypoint_ids, ibeg, imid, iend, keypoints) {
	// Merge keypoint lists from ibeg-imid and imid-iend. If the complete merge
	// doesn't happen, then return the origin keypoint_ids list.
	console.debug("   $> Merge on " + ibeg + ", " + imid + ", " + iend);
	var finished = true;
	merged_keypoint_ids = keypoint_ids.slice()
	//// for help visualizing
	for (var m = ibeg; m < iend; m++) {
		merged_keypoint_ids[m] = -1;
	}
	 //// delete it later ^^
	var i = ibeg, j = imid;
	for (var k = ibeg; k < iend; k++) {
		if (i < imid && j >= iend) {
			merged_keypoint_ids[k] = keypoint_ids[i];
			i++;
		} else if (i >= imid && j < iend) {
			merged_keypoint_ids[k] = keypoint_ids[j];
			j++;
		} else if (i < imid && j < iend) {
			var cmpres = CmpKeypoints(keypoint_ids, i, j, keypoints);
			finished = cmpres[0];
			var cmp = cmpres[1], unsure = cmpres[2];
			if (finished == false) {
				// End this run of MergeSort since we need to wait for the
				// Turker to make a decision on this comparison
				break;
			}
			// // For an unsure comparison, k_id2 will be "removed" from 
			// // keypoint_ids and the MergeSort will continue. Then after the
			// // MergeSort has finished, k_id2 will be reinserted into keypoint_ids.
			// if (unsure) {
			// 	merged_keypoint_ids[k] = keypoint_ids[i];
			// 	i++;
			// 	j++; k++;
			// }
			// console.log("cmp = " + cmp);
			if (cmp < 0) {
				merged_keypoint_ids[k] = keypoint_ids[i];
				i++;
			} else {
				merged_keypoint_ids[k] = keypoint_ids[j];
				j++;
			}
			// console.log("MERGED KEYPOINTS PART WAY");
			// console.log(merged_keypoint_ids);
		}

	}
	// console.log(keypoint_comparisons_res[k_id1 + ',' + k_id2])
	// console.log("merged_keypoint_ids = " + merged_keypoint_ids);
	// console.log("keypoint_ids = " + keypoint_ids);
	if (finished == true) {
		keypoint_ids = merged_keypoint_ids;
		// console.log("keypoint_ids = " + keypoint_ids);
		
		// var stringy = "";
		// for(var ki = 0; ki < res[1].length; ki++) {
		// 	stringy += keypoint_labels[res[1][ki]] + " ";
		// }
		// console.log(stringy);


		return [true, keypoint_ids];
	}
	return [false, []];
}

/**
 * Returns result array
 *     result[0]: Boolean whether this comparison has been done before
 *     result[1]: -1 if i is closer than j, 0 if they are same distance, 1 if
 * 				  j is closer than i. In other words, true if 
 * 				  keypoints_ids[i] <= keypoints_ids[j] aka i is closer than j
 */
function CmpKeypoints(keypoint_ids, i, j, keypoints) {
	k_id1 = keypoint_ids[i];
	k_id2 = keypoint_ids[j];
	

	key = k_id1.toString() + ',' + k_id2.toString();
	console.debug("   $> CmpKeypoints compare " + k_id1 + " at index i and " + k_id2 + " at index j");

	// If this comparison has been done before, but it was an unsure, return.
	// Deal with unsures after MergeSort is done.
	if (keypoint_comparisons_unsure.includes(key)) {
		// console.log("Comparison unsure with " + key);
		// Treat unsures as same distance. Clear it up after MergeSort finishes
		return [true, 0];
	} else if (k_id1 + ',' + k_id2 in keypoint_comparisons_res) {
		// If this comparison has been done before, continue the merge sort.
		// console.log("Cached comparison = " + keypoint_comparisons_res[k_id1 + ',' + k_id2]);
		return [true, keypoint_comparisons_res[key]];
	} else if (i == j) {
		console.warn("   $> CmpKeypoints() compared a keypoint against itself");
		return [true, 0]
	}
	
	// Prevent a keypoint from jumping from one color the other in adjacent comparisons
	if (keypoint_id1 == k_id2 || keypoint_id2 == k_id1) {
		var temp = k_id1;
		k_id1 = k_id2;
		k_id2 = temp;
	}
		
	console.debug("   $> Use Turker for k_id1 = " + k_id1 + ", k_id2 = " + k_id2);
	// console.log("keypoint_ids = " + keypoint_ids);
	k_ind1 = k_id1 * 3;
	k_ind2 = k_id2 * 3;
	ImagePairKeypoints(keypoints[k_ind1], keypoints[k_ind1 + 1], keypoints[k_ind2], keypoints[k_ind2 + 1], k_id1, k_id2);
	return [false, undefined]
}


/**
 * 
 */
function ReinsertUnsureComparisons(keypoint_ids, keypoints) {
	console.debug("_____________ DEBUG _____________: in /ReinsertUnsureComparisons()");

	// console.log(keypoint_comparisons_res);
	// console.log(keypoint_ids);

	var cmpFound = true;
	for (var c = keypoint_comparisons_unsure.length - 1; c >= 0; c--) {
		k_id = parseInt(keypoint_comparisons_unsure[c].split(',')[0]);
		k_ind = keypoint_ids.indexOf(k_id);
		// console.log('for loop index = ' + c + ", k_id = " + k_id + ", and k_ind = " + k_ind);

		// Find the first keypoint closer to the camera which is a different
		// distance.
		var k_ind_other = k_ind - 1;
		while (k_ind_other >= 0) {
			// console.log("k_ind_other first while = " + k_ind_other);

			var key = k_id.toString() + ',' + keypoint_ids[k_ind_other].toString();
			// console.log("Looking for key = " + key);

			if (key in keypoint_comparisons_unsure) {
				// This pair is unsure. Continue.
				// console.log("unsure");
			} else if (key in keypoint_comparisons_res && keypoint_comparisons_res[key] == 0) {
				// This pair is the same distance, but we want the first
				// instance of a different distance. Continue.
				// console.log("same");
			} else if (key in keypoint_comparisons_res && keypoint_comparisons_res[key] != 0) {
				// This pair is the first comparison where they are different
				// distances! We are done.
				// console.log("Do the break with value of " + keypoint_comparisons_res[key]);
				break;				
			} else if (!(key in keypoint_comparisons_res)) {
				// This pair hasn't been examined yet. Ask a Turk to assess.
				// console.log("Do the imagepairkeypoints");
				keypoint_comparisons_unsure.pop();
				keypoint_comparisons_unsure.pop();
				c--;
				ImagePairKeypoints(keypoints[k_id*3], keypoints[k_id*3 + 1], keypoints[k_ind_other*3], keypoints[k_ind_other*3 + 1], k_id, keypoint_ids[k_ind_other]);
				cmpFound = false;
				break;
			}
			k_ind_other--;
		}

		if (!cmpFound) {
			return cmpFound;
		}

		// Find the first keypoint farther from the camera which is a different
		// distance.
		k_ind_other = k_ind + 1;
		while (k_ind_other < keypoint_ids.length) {
			// console.log("k_ind_other second while = " + k_ind_other);
			var key = k_id.toString() + ',' + keypoint_ids[k_ind_other].toString();
			// console.log("Looking for key = " + key);
			if (key in keypoint_comparisons_unsure) {
				// This pair is unsure. Continue.
			} else if (key in keypoint_comparisons_res && keypoint_comparisons_res[key] == 0) {
				// This pair is the same distance, but we want the first
				// instance of a different distance. Continue.
			} else if (key in keypoint_comparisons_res && keypoint_comparisons_res[key] != 0) {
				// This pair is the first comparison where they are different
				// distances! We are done.
				// console.log("Do the break 2 with value of " + keypoint_comparisons_res[key]);
				break;				
			} else if (!(key in keypoint_comparisons_res)) {
				// This pair hasn't been examined yet. Ask a Turk to assess.
				// console.log("Do teh imagepairkeypoints 2 on k_id = " + k_id + " and keypoint_ids[k_ind_other] = " + keypoint_ids[k_ind_other]);
				keypoint_comparisons_unsure.pop();
				keypoint_comparisons_unsure.pop();
				c--;
				ImagePairKeypoints(keypoints[k_id*3], keypoints[k_id*3 + 1], keypoints[k_ind_other*3], keypoints[k_ind_other*3 + 1], k_id, keypoint_ids[k_ind_other]);
				cmpFound = false;
				break;
			}
			k_ind_other++;
		}

	}
	// console.log("But im done with " + cmpFound);
	return cmpFound;
}


/**
 * Continuously draws two points on the canvas representing two keypoints.
 */
function ImagePairKeypoints( x1, y1, x2, y2, k_id1, k_id2 ) {
	console.debug("_____________ DEBUG _____________: in /ImagePairKeypoints()");
	
	keypoint_id1 = k_id1;
	keypoint_id2 = k_id2;

	// This is prone to XSS injections
	$("#green_closer_button").html("<b>" + keypoint_labels[k_id1] + "</b> is closer");
	$("#pink_closer_button").html("<b>" + keypoint_labels[k_id2] + "</b> is closer");

	var percentage_left = Math.round(comparisons_left * 1.0 / MAX_COMPARISONS * 100);
	$("#comparisons-left").html("<b>" + percentage_left + "</b> percent to go");

	// keypoints = image_keypoints_list['image_keypoints_' + cur_trial]
	var c = canvas;
		var ctx = c[0].getContext('2d');

		var draw = function(x1, y1, x2, y2){
		//console.log("x1 = " + x1 + " y1 = " + y1);
		ctx.beginPath();
		ctx.strokeStyle="#00FF00";
			ctx.lineWidth=2;
		ctx.moveTo(x1, y1)
		ctx.arc(x1, y1, 7, 0, 2*Math.PI)
		ctx.stroke();

		ctx.beginPath();
		ctx.strokeStyle="#ff33ff";
		ctx.moveTo(x2, y2)
		ctx.arc(x2, y2, 7, 0, 2*Math.PI)
		ctx.stroke();
		 };

	// Draw the keypoints every 100ms. So if the canvas is resized, the
	// keypoints are redrawn. Sadly, this seems like the best way to do it.
	clearInterval(drawInterval);
	drawInterval = setInterval(function(){
		if (canvas_visible) {
		canvas.css("visibility", "visible");
		ctx.canvas.height = image_bbox_height;
		ctx.canvas.width = image_bbox_width;
		canvas.css("position", "absolute");
		draw(x1+image_bbox_left, y1+image_bbox_top, x2+image_bbox_left, y2+image_bbox_top);
		} else {
			canvas.css("visibility", "hidden");
		}
	}, 100);
}


/**
 * Infer comparisons from past comparisons about the current passedin comparison.
 * @param k_id1: keypoint id of first current keypoint being compared
 * @param k_id2: keypoint id of second current keypoint being compared
 * @param res: result from k_id1, k_id2 comparison
 */
 function InferKeypointComparisons(k_id1, k_id2, res) {

	console.debug("_____________ DEBUG _____________: in /infer_keypoint_comparisons()");

	// OPTIMIZATION: Reduce number of comparisons by using Same Distance to
	// to infer keypoint comparisons.
	// First get all known information on the two keypoints.
	var equids_k_id1 = [], closer_k_id1 = [], farther_k_id1 = [];
	var equids_k_id2 = [], closer_k_id2 = [], farther_k_id2 = [];
	for (kmp in keypoint_comparisons_res) {
		if (keypoint_comparisons_res.hasOwnProperty(kmp)) {
			console.log(kmp);
			kmpsplit = kmp.split(',');
			kmp_k_id1 = parseInt(kmpsplit[0]);
			kmp_k_id2 = parseInt(kmpsplit[1]);
			if (k_id1 == kmp_k_id1 && keypoint_comparisons_res[kmp] == 0) {
				equids_k_id1.push(kmp_k_id2);
			} else if (k_id1 == kmp_k_id1 && keypoint_comparisons_res[kmp] < 0) {
				closer_k_id1.push(kmp_k_id2);
			} else if (k_id1 == kmp_k_id1 && keypoint_comparisons_res[kmp] > 0) {
				farther_k_id1.push(kmp_k_id2);
			} else if (k_id2 == kmp_k_id1 && keypoint_comparisons_res[kmp] == 0) {
				equids_k_id2.push(kmp_k_id2);
			} else if (k_id2 == kmp_k_id1 && keypoint_comparisons_res[kmp] < 0) {
				closer_k_id2.push(kmp_k_id2);
			} else if (k_id2 == kmp_k_id1 && keypoint_comparisons_res[kmp] > 0) {
				farther_k_id2.push(kmp_k_id2);
			}
		}
	}
	
	// If k_id1 and k_id2 are same distance, union the two equids lists
	if (res === 0) {
		var equids = equids_k_id1.concat(equids_k_id2);
		// Remove duplicates in equids
		equids = equids.filter( function( item, index, inputArray ) {
			return inputArray.indexOf(item) == index; });
		// Add every pair possible in equids into keypoint_comparisons_res if not
		// already there.
		for (var i = 0; i < equids.length; i++) {
			for (var j = i + 1; j < equids.length; j++) {
				var key = equids[i] + ',' + equids[j];
				if (!(key in keypoint_comparisons_res)) {
					keypoint_comparisons_res[key] = 0;
				}
				key = equids[j] + ',' + equids[i];
				if (!(key in keypoint_comparisons_res)) {
					keypoint_comparisons_res[key] = 0;
				}
			}
		}
	}

	// If k_id1 is closer than k_id2, then we can infer several situations
	// - if k_id1 == k_id3 then k_id3 < k_id2
	// - if k_id2 == k_id3 then k_id1 < k_id3
	// - if k_id3 < k_id1 then k_id3 < k_id2. Not implemented bc mergesort
	// - if k_id2 < k_id3 then k_id1 < k_id3. Not implemented bc mergesort
	if (res < 0) {
		// First situation
		for (var ei = 0; ei < equids_k_id1.length; ei++) {
			var key = equids_k_id1[ei] + ',' + k_id2;
			if(!(key in keypoint_comparisons_res)) {
				keypoint_comparisons_res[key] = -1;
			}
			var antikey = k_id2 + ',' + equids_k_id1[ei];
			if(!(antikey in keypoint_comparisons_res)) {
				keypoint_comparisons_res[antikey] = 1;
			}
		}
		// Second situation
		for (var ei = 0; ei < equids_k_id2.length; ei++) {
			var key = k_id1 + ',' + equids_k_id2[ei];
			if(!(key in keypoint_comparisons_res)) {
				keypoint_comparisons_res[key] = -1;
			}
			var antikey = equids_k_id2[ei] + ',' + k_id1;
			if(!(antikey in keypoint_comparisons_res)) {
				keypoint_comparisons_res[antikey] = 1;
			}
		}
	}

	// if k_id1 is farther than k_id2, then we can infer several situations
	// if k_id1 == k_id3 then k_id2 < k_id3
	// if k_id2 == k_id3 then k_id3 < k_id1
	// etc.
	if (res > 0) {
		// First situation
		for (var ei = 0; ei < equids_k_id1.length; ei++) {
			var key = k_id2 + ',' + equids_k_id1[ei];
			if(!(key in keypoint_comparisons_res)) {
				keypoint_comparisons_res[key] = -1;
			}
			var antikey = equids_k_id1[ei] + ',' + k_id2;
			if(!(antikey in keypoint_comparisons_res)) {
				keypoint_comparisons_res[antikey] = 1;
			}
		}
		// Second situation
		for (var ei = 0; ei < equids_k_id2.length; ei++) {
			var key = equids_k_id2[ei] + ',' + k_id1;
			if(!(key in keypoint_comparisons_res)) {
				keypoint_comparisons_res[key] = -1;
			}
			var antikey = k_id1 + ',' + equids_k_id2[ei];
			if(!(antikey in keypoint_comparisons_res)) {
				keypoint_comparisons_res[antikey] = 1;
			}
		}
	}
 }


/**
 * Fired after Turker makes a decision on a keypoint pair. It is the callback
 * function to continue the MergeSort.
 */
function StepMergeSort() {

	console.debug("_____________ DEBUG _____________: in /StepMergeSort()");

	var button_id = $(this).attr('id');
	var k_id1 = keypoint_id1;
	var k_id2 = keypoint_id2;
	var key = k_id1.toString() + ',' + k_id2.toString();
	var antikey = k_id2.toString() + ',' + k_id1.toString();

	// console.log(key);

	if (button_id == "unsure_distance_button") {
		keypoint_comparisons_unsure.push(key);
		keypoint_comparisons_unsure.push(antikey);
		// Pretend Unsure is the same as Same Distance. Remove these after
		// MergeSort is done
		keypoint_comparisons_res[key] = 0;
		keypoint_comparisons_res[antikey] = 0;

		comparisons_left += 2;
	} else {
		var res;
		if (button_id == "green_closer_button") {
			res = -1;
		} else if (button_id == "pink_closer_button") {
			res = 1;
		} else if (button_id == "neither_closer_button") {
			res = 0;
		} else {
			console.warn("StepMergeSort(): Problem with reading button id");
		}
		//console.log(button_id);
		//console.log(this);
		//console.log($(this));
		// console.log(res);

		// console.log("PUT IT IN");
		// Store the result of the current comparison
		keypoint_comparisons_res[key] = res;
		keypoint_comparisons_res[antikey] = -res;

		// Infer more comparisons from past and current comparisons
		InferKeypointComparisons(k_id1, k_id2, res);
		
		// Don't decrement comparisons left if Unsure was chosen
		comparisons_left = Math.max(comparisons_left - 1, 1);
	}
	keypoint_comparisons_order.push(key)

	// Restart the MergeSort but now with the new information
	DoTrial();
}

/**
 * Backtrack one comparison.
 */
function Backstep() {
	var new_keypoint_comparisons_res = {};
	
	if (keypoint_comparisons_order.length > 0) {
		comparisons_left += 1;
		// Keep all the keypoints we've done except for the last one.	
		console.log("keypoint_comparisons_order = " + keypoint_comparisons_order);
		keypoint_comparisons_order.pop();
		console.log("popped keypoint_comparisons_order = " + keypoint_comparisons_order);
		for (var i = 0; i < keypoint_comparisons_order.length; i++) {
			var key = keypoint_comparisons_order[i];
			kmpsplit = key.split(',');
			kmp_k_id1 = parseInt(kmpsplit[0]);
			kmp_k_id2 = parseInt(kmpsplit[1]);
			var antikey = kmp_k_id2.toString() + ',' + kmp_k_id1.toString();
		
			new_keypoint_comparisons_res[key] = keypoint_comparisons_res[key];
			new_keypoint_comparisons_res[antikey] = keypoint_comparisons_res[antikey];
		}
		keypoint_comparisons_res = new_keypoint_comparisons_res;
		
	clearInterval(drawInterval);
		DoTrial();
	}
}

function NextTrial() {

	console.debug("_____________ DEBUG _____________: in /NextTrial()");
	
	// get timing for the trial just completed
	var currentTime = new Date().getTime();
	var RT = currentTime - startTrialTime;
	$('#response_time_' + cur_trial).val(RT);
	console.debug('   $> Completed trial: ' + cur_trial + " in msec: " + RT);
	
	// Increment number of completed trials
	compl_trials = compl_trials + 1;
	console.debug('   $> Number of completed trials: ' + compl_trials);

	// Extract id of the button that was pressed
	
	/*
	var button_id = $(event.target).attr('id');
	console.debug('   $> NextTrial() pressed by -> ' + button_id);
	// set trial_flag to true if turker pressed the flag_image_button
	var _trial_flag = false;
	if (button_id == 'flag_image_button') {
		_trial_flag = true;
	}
	
	// determine if any comment on image has been provided, if yes store it
	var _trial_comment = '';
	if ( $('#_trial_comment').val() != 'Write here if you have specific concerns about the image.')
	{
		_trial_comment = $('#_trial_comment').val();
	}
	*/

	// Pack up the information from this trial.
	var depth_info = {};
	depth_info['keypoint_comparisons_unsure'] = keypoint_comparisons_unsure;
	depth_info['keypoint_comparisons_res'] = keypoint_comparisons_res;
	depth_info['keypoint_comparisons_order'] = keypoint_comparisons_order;
	var depth_str = JSON.stringify(depth_info);
	
	var _trial_results = {
			"_{{ dataset }}_subj_id": subj_id_list[cur_trial - 1], 
			"_depth_str": depth_str,
			"_assignment_id": _amt_assignment_id,
			"_hit_id": parseInt(_hit_id),
			"_worker_id": _amt_worker_id,
			//"_trial_flag": _trial_flag,
			"_trial_rt": RT,
			"_trial_num": cur_trial - 1,
			//"_trial_comment": _trial_comment
	};
	
	console.debug('   $> trial results: ' + JSON.stringify(_trial_results) );
	
	_all_trials_res_dict[cur_trial - 1] = _trial_results;
	
	console.debug( JSON.stringify(_all_trials_res_dict) );

	// save results of annotation on server. ajax post sends the data to
	// the server python flask application that will save it on disk
	$.ajax({
		url: "/cocoa_depth/{{ dataset }}/PostTrialResults/", 
		type: "POST",
		contentType: "application/json",
		data: JSON.stringify(_trial_results),
		dataType: "text",
		success: function( data ) {
			console.debug( "   $> PostTrialResults() success: " + data );
		}
	});
	
	// store trial interactions string into a total interactions string
	_total_depth_str = _total_depth_str + "***" + depth_str;
	
	// clean up variables for next subject that will be annotated
	
	// Initialize the string that will contain the info on the 
	// interactions for the subject
	depth_str = '';
	// Initialize the string that will contain the html string 
	// visualizing the annotations for the subject 
	// interactions_panel_str = '';	
	// Empty the annotation box HTML
	// $('#annotation_box_container_obj').html("");
	// Empty the string of active keys (for image mapster)
	// keysActive = "";
	
	// Unbind all functions from the image (image mapster)
	// image.mapster('unbind');
	// image.unbind('mouseover');
	// image.unbind('mouseout');

	keypoint_comparisons_unsure = [];
	keypoint_comparisons_res = {};
	keypoint_comparisons_order = [];
	clearInterval(drawInterval);
	mergeSortFinished = false;
	sortedKeypointIds = undefined;
	comparisons_left = MAX_COMPARISONS;

	$('#t' + cur_trial + '_img').hide();
	$('#_trial_comment').val('Write here if you have specific concerns about the image.');
	$('#button_panel').hide();
	$('#ann_container').hide();

	// Hide instructions if they are visible
	flag_view_instructions = 1;
	ManageInstructions();
	
	if (cur_trial < num_trials) {
		
		// set the flag to false so that pressing space will launch new trial
		flag_trial_run = false;
		
		cur_trial++;
		$('#startTrial').show();
	} else {
		
		// get timing for all the assignment
		var currentTime = new Date().getTime();
		totalAssignmentTime = currentTime - startAssignmentTime;
		$('#_hit_rt').val(totalAssignmentTime);
		console.debug('   $> Completed whole assignment in msec: ' + totalAssignmentTime);
		$('#_hit_depth_str').val(_total_depth_str);
		console.debug('   $> Total depth string: ' + _total_depth_str);
		$('#_trials_results').val(JSON.stringify(_all_trials_res_dict));
		console.debug('   $> All trials results: ' + JSON.stringify(_all_trials_res_dict));
		var varbool =  totalAssignmentTime <= 30000;
		console.debug('Test: ' + varbool.toString());
		// a few sanity checks to decide if work was good or bad
		if( totalAssignmentTime <= 30000 ) {
			alert("Your assignment doesn't meet our quality requirements. Please RETURN HIT or it will be automatically rejected. Thanks!");
			$('#_hit_reject_flag').val(true);
			// could add worker id to bad list
		}else{
			$('#_hit_reject_flag').val(false);
		}
		
		$('#submitButton').show();
		$('#thanks').show();
		$('#experiment').hide();
	}
}

function ManageInstructions() {
	
	if (flag_view_instructions == 1) {
		flag_view_instructions = 0;
		$('#show_hide_instr').html('Show');
		$('#all_instruction_container').hide();
	} else {
		flag_view_instructions = 1;
		$('#show_hide_instr').html('Hide');
		$('#all_instruction_container').show();
	}
}

</script>

<style>
#experiment {
	margin-left: auto;
	margin-right: auto;
	width: 70%;
	font-family: Arial, Helvetica;
	text-align: justify;
}

.image_instruction {
	float: left;
	margin: 5px;
	width: 400px;
}

#experiment_container_big {
	width: 100%;
}

#experiment_container {
	overflow: hidden;
}

#image_container_big {
	float:left;
	margin-left: 30px;
	margin-right: 30px;
	margin-bottom: 30px;
	margin-top: 15px;
}

#image_container {
	position: relative;
	background: gray;
	min-width: 300px;
	min-height: 25px;
	margin-bottom: 30px;
}

#ann_container {
	display: none;
	float: left;
	overflow: hidden;
	margin-left: 30px;
}

#annotation_box {
	margin: 5px;
}

#startTrial {
	position: absolute;
	top: 0px;
	left: 45px;
	font-weight: bold;
	color: white;
	font-size: 14pt;
	width: 285px;
}

.displays {
	display: none;
	top: 0px;
	left: 0px;
}

#thanks {
	display: none;
}

</style>

<div id="experiment">

<h3>Determine the body part closest to the camera</h3>

<ul>
<li>You'll be presented with an image of a human with one green and one pink circle on a body part.</li>
<li>Select in each image which body part is closer to the camera taking the picture.</li>
<li><b><font color="red">Read the 3 examples</font></b> to understand all the possible scenarios you might face.</li>
<li><b><font color="red">Do not complete the HIT in less than 1 minute.</font></b></li>
<li>Hide / show the instructions by pressing the button below.</li>
<li>Same distance is defined as within 6 inches (15 cm) of each other from the camera.</li>
<li>Press the Toggle Circles button if you need to see the picture without the overlaid circles.</li>
</ul>

<div id="instruction_button">
	<p><b>Instructions:</b><button id="show_hide_instr" onclick="ManageInstructions()" style="margin-left: 30px;">Hide</button><p>
</div>

<div id="all_instruction_container">
	<div id="image_instruction_container">
		<div class="image_instruction">
			<p><b>Example 1: (Standard case)</b></p>
			<p>This woman in the picture is the annotated subject. She has a pink circle on
				her knee and a green circle on her hip. She is walking so her knee is in front
				of her hip. Thus it should be annotated the pink circle is closer to the camera.</p>
			<!-- <p>Hover the mouse over the image to visualize all the objects in the image.</p> -->
			<img src="/static/images/1.png" width="400px" border="3" style="margin-bottom:5px;">
			<!-- <p>The subject <b>is</b> interacting with objects:</p>
			<ul>
			<li>click all the objects involved (he is throwing a <b>frisbee</b>).</li>
			</ul>
			<p>The subject <b>is</b> involved in actions with people:</p>
			<ul>
			<li>click all the people involved (he is playing with <b>three people</b>).</li>
			</ul>			 -->
			<!-- <img src="/static/images/2.png" width="400px" border="3" style="margin-bottom:5px;">
			<p>For this subject, the <b>frisbee</b> and the <b>three people</b> were selected.</p>
			<p>Press the "Done!" button</p> -->
		</div>
		<div class="image_instruction">
			<p><b>Example 2: (Close cases)</b></p>
			<p>The woman has two circles her knees.</p>
			<p>Because the two nees are within 6 inches of each other from the camera, this is considered same distance.</p>
			<img src="/static/images/2new.png" width="400px" border="3" style="margin-bottom:5px;">
			<!-- <p>The subject <b>is</b> interacting with objects:</p>
			<ul>
			<li>click all the objects involved (she is wearing a <b>purse</b> and sitting on a <b>bench</b>).</li>
			</ul>
			<p>The subject <b>is</b> involved in actions with people:</p>
			<ul>
			<li>click all the people involved (she is sitting next to her <b>partner</b>).</li>
			</ul>		
			<img src="/static/images/1_2.png" width="400px" border="3" style="margin-bottom:5px;">
			<p>For this subject, the <b>purse</b>, the <b>bench</b> and her <b>partner</b> were selected.</p>
			<p>Press the "Done!" button</p>
			<p><b>Note:</b> Although other people are on the bench, they were not selected as not related / interacting with the subject.</p>
			<p>Here are a few examples of images with crowds.</p>
			<p>The subject <b>is</b> interacting with everybody (posing) and with her tennis racket:</p>
			<img src="/static/images/crowd_1.png" width="400px" border="3" style="margin-bottom:5px;">
			<p>The subject <b>is not</b> interacting with other people (but is sitting on the bench):</p>
			<img src="/static/images/crowd_2.png" width="400px" border="3" style="margin-bottom:5px;">
			<p>The subject <b>is</b> interacting only with part of the crowd (just the person next to her):</p>
			<img src="/static/images/crowd_3.png" width="400px" border="3" style="margin-bottom:5px;">
			<img src="/static/images/crowd_4.png" width="400px" border="3" style="margin-bottom:5px;">
			<p><b>Note:</b> the subject <b>is not</b> interacting with the foreground person.</p> -->
		</div>
		<div style="clear:both"></div>
	</div>

	<div id="image_instruction_container">
		<div class="image_instruction">
			<p><b>Example 3: (Same Distance from Uncertainty)</b></p>
			<p>Sometimes keypoints are farther apart spatially, but they are still the Same Distance
				from the camera. In this picture, her knees look like they are within 6 inches of each
				other from the camera and should be marked Same Distance.</p>
			<!-- <ul><li>i.e. <b>cell phones</b>, <b>remotes</b>, <b>food / drinks</b></li></ul>
			<p>or partially occlude the objects they interact with:</p>
			<ul><li>i.e. <b>benches / chairs</b>, <b>backpacks</b>, <b>utensils</b></li></ul>
			<p>Make sure you select all the objects that are being used by / related to a subject.</p>
			<p>Here are a few examples of images with objects that were hard to catch.</p>
			<p>The <b>skies</b>:</p> -->
			<img src="/static/images/3.png" width="400px" border="3" style="margin-bottom:5px;">
			<!-- <p>The <b>phone</b> and the <b>motorcycle</b>:</p> -->
			<!-- <img src="/static/images/small_2.png" width="400px" border="3" style="margin-bottom:5px;">
			<p>The <b>phone</b> and the <b>tie</b>:</p>
			<img src="/static/images/small_3.png" width="400px" border="3" style="margin-bottom:5px;"> -->
		</div>
		<!-- <div class="image_instruction">
			<p><b>Example 4: (When to flag an image)</b></p>
			<p>If the image content is <b>ambiguous</b>, i.e. the subject is mostly occluded or invisible:</p>
			<ul>
				<li>follow the previous examples at your best.</li>
				<li>press the "Flag" button.</li>
			</ul>
			<p>Here are a few examples of images that you should flag.</p>
			<img src="/static/images/flag_1.png" width="400px" border="3" style="margin-bottom:5px;">
			<img src="/static/images/flag_2.png" width="400px" border="3" style="margin-bottom:5px;">		
			<img src="/static/images/flag_3.png" width="400px" border="3" style="margin-bottom:5px;">
			<img src="/static/images/flag_4.png" width="400px" border="3" style="margin-bottom:5px;">
			<img src="/static/images/flag_5.png" width="400px" border="3" style="margin-bottom:5px;">
		</div> -->
		<div style="clear:both"></div>
	</div>
	
</div>

<div id = "experiment_container_big">
	<div id="experiment_container">
	
		<div id="image_container_big">
		<div id="image_container">
			<a href="javascript:SetupTrial()" id="startTrial">Start Trial (press space)</a>
		</div>
		<div id="button_panel" style="display:none;">
			<div id="sort_buttons">
				<div style="margin-bottom:10px;"><button id="toggle_canvas">Toggle Circles</button>
				<button id="backtrack_comparison_button">Go Back</button></div>
				<div id="comparisons-left" style="margin-bottom:20px;"></div>
				<div style="margin-bottom:10px;"><button id="green_closer_button" style="background-color:#00FF00">Green is Closer</button></div>
				<div style="margin-bottom:10px;"><button id="pink_closer_button" style="background-color:#ff33ff">Pink is Closer</button></div>
				<div style="margin-bottom:10px;"><button id="neither_closer_button">Same Distance</button></div>
				<!-- <div><button id="unsure_distance_button" onclick="StepMergeSort()">Unsure</button></div> -->
			</div>
			<!-- <div id="done_buttons">
				<ul>
					<li>Press <b>Flag</b> if something went wrong during annotation.</li>
					<li>Press <b>Done</b> if you are finished!</li>
				</ul>
				<button id="flag_image_button" onclick="NextTrial()">Flag</button>
				<button id="done_subject_button" onclick="NextTrial()">Done!</button>
				<div style="margin:5px;"> Comments: </div>
				<div><textarea id="_trial_comment" rows="4" cols="50">Write here if you have specific concerns about the image.</textarea></div>
			</div> -->
		</div>
		</div>

	</div>
</div>

</div>

<div id="thanks" style="margin-bottom:5px;">
	
<form action="https://www.mturk.com/mturk/externalSubmit" method="POST">
<!-- <form action="https://workersandbox.mturk.com/mturk/externalSubmit" method="POST"> -->
	<p>Thanks! Please fill the following and submit:</p>
	<div style="border-style: solid; border-width:3px; width:500px;">

	<div style="margin: 5px;">
			Notify this HIT? (I.e. Did a mistake / something went wrong)
			<input type="radio" id="_hit_flag" name="_hit_flag" value="Yes">Yes
			<input type="radio" id="_hit_flag" name="_hit_flag" value="No">No 
	</div> 

	<div style="margin-left:5px;">HIT usability: ( <input type="text" id="_gui_rating" name="_gui_rating" value="" size="2"> ) / 10</div>
	<div style="margin: 5px;">Comments: <input type="text" id="_hit_comment" name="_hit_comment" style="width:100%" value=""></div>

	<input type="hidden" id="_hit_id" name="_hit_id" value="">
	<!-- Why are there two assignment id fields... -->
	<input type="hidden" id="assignmentId" name="assignmentId" value="">
	<input type="hidden" id="_assignment_id" name="_assignment_id" value="">
	<input type="hidden" id="_worker_id" name="_worker_id" value="">
	<input type="hidden" id="_worker_exp" name="_worker_exp" value="">
	<input type="hidden" id="_hit_it" name="_hit_it" value="">
	<input type="hidden" id="_hit_rt" name="_hit_rt" value="">
	<input type="hidden" id="_trials_results" name="_trials_results" value="">
	<input type="hidden" id="_hit_depth_str" name="_hit_depth_str" value="">
	<input type="hidden" id="_hit_reject_flag" name="_hit_reject_flag" value="">

	
	</div>
	<div id="submit_div" style="display: none;">
		<input type="submit" id="submitButton">
	</div>
</form>
</div>




